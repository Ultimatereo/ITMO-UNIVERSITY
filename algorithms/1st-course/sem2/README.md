ИТМО, Лабораторная по алгоритмам, y2021 2 семестр (Весна 2022)
1A. RSQ
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Входные данные
В первой строке находится число n — размер массива. (1≤n≤500000) Во второй строке находится n чисел ai — элементы массива. Далее содержится описание операций, их количество не превышает 1000000. В каждой строке находится одна из следующих операций:

set i x — установить a[i] в x.
sum i j — вывести значение суммы элементов в массиве на отрезке с i по j, гарантируется, что (1≤i≤j≤n).
Все числа во входном файле и результаты выполнения всех операций не превышают по модулю 1018.
Выходные данные
Выведите последовательно результат выполнения всех операций sum. Следуйте формату выходного файла из примера.

Пример
входные данныеСкопировать
5
1 2 3 4 5
sum 2 5
sum 1 5
sum 1 4
sum 2 4
set 1 10
set 2 3
set 5 2
sum 2 5
sum 1 5
sum 1 4
sum 2 4
выходные данныеСкопировать
14
15
10
9
12
22
20
10
1B. RMQ
ограничение по времени на тест4 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Входные данные
В первой строке находится число n — размер массива. (1 ≤ n ≤ 500000) Во второй строке находится n чисел ai — элементы массива. Далее содержится описание операций, их количество не превышает 1000000. В каждой строке находится одна из следующих операций:

set i x — установить a[i] в x.
min i j — вывести значение минимального элемента в массиве на отрезке с i по j, гарантируется, что (1 ≤ i ≤ j ≤ n).
В массив помещаются только целые числа, не превышающие по модулю 109.
Выходные данные
Выведите последовательно результат выполнения всех операций min. Следуйте формату выходного файла из примера.

Пример
входные данныеСкопировать
5
1 2 3 4 5
min 2 5
min 1 5
min 1 4
min 2 4
set 1 10
set 2 3
set 5 2
min 2 5
min 1 5
min 1 4
min 2 4
выходные данныеСкопировать
2
1
1
2
2
2
3
3
1C. Художник
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Итальянский художник-абстракционист Ф. Мандарино увлекся рисованием одномерных черно-белых картин. Он пытается найти оптимальное местоположение и количество черных участков картины. Для этого он проводит на прямой белые и черные отрезки, и после каждой из таких операций хочет знать количество черных отрезков на получившейся картине и их суммарную длину.

Изначально прямая — белая. Ваша задача — написать программу, которая после каждой из таких операций выводит в выходной файл интересующие художника данные.

Входные данные
В первой строке входного файла содержится общее количество нарисованных отрезков (1≤n≤100000). В последующих n строках содержится описание операций. Каждая операция описывается строкой вида c x l, где c — цвет отрезка (W для белых отрезков, B для черных), а сам отрезок имеет вид [x;x+l), причем координаты обоих концов — целые числа, не превосходящие по модулю 500000. Длина задается положительным целым числом.

Выходные данные
После выполнения каждой из операций необходимо вывести в выходной файл на отдельной строке количество черных отрезков на картине и их суммарную длину, разделенные одним пробелом.

Пример
входные данныеСкопировать
7
W 2 3
B 2 2
B 4 2
B 3 2
B 7 2
W 3 1
W 0 10
выходные данныеСкопировать
0 0
1 2
1 4
1 4
2 6
3 5
0 0
1D. RMQ2
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Входные данные
В первой строке находится число n — размер массива. (1≤n≤105) Во второй строке находится n чисел ai — элементы массива. Далее содержится описание операций, их количество не превышает 2⋅105. В каждой строке находится одна из следующих операций:

set i j x — установить все a[k], i≤k≤j в x.
add i j x — увеличить все a[k], i≤k≤j на x.
min i j — вывести значение минимального элемента в массиве на отрезке с i по j, гарантируется, что (1≤i≤j≤n).
Все числа во входном файле и результаты выполнения всех операций не превышают по модулю 1018.
Выходные данные
Выведите последовательно результат выполнения всех операций min. Следуйте формату выходного файла из примера.

Пример
входные данныеСкопировать
5
1 2 3 4 5
min 2 5
min 1 5
min 1 4
min 2 4
set 1 3 10
add 2 4 4
min 2 5
min 1 5
min 1 4
min 2 4
выходные данныеСкопировать
2
1
1
2
5
5
8
8
1E. RMQ наоборот
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводrmq.in
выводrmq.out
Рассмотрим массив a[1..n]. Пусть Q(i, j) — ответ на запрос о нахождении минимума среди чисел a[i], ..., a[j]. Вам даны несколько запросов и ответы на них. Восстановите исходный массив.

Входные данные
Первая строка входного файла содержит число n — размер массива, и m — число запросов (1 ≤ n, m ≤ 100 000). Следующие m строк содержат по три целых числа i, j и q, означающих, что Q(i, j) = q (1 ≤ i ≤ j ≤ n,  - 231 ≤ q ≤ 231 - 1).

Выходные данные
Если искомого массива не существует, выведите строку «inconsistent».

В противном случае в первую строку выходного файла выведите «consistent». Во вторую строку выходного файла выведите элементы массива. Элементами массива должны быть целые числа в интервале от  - 231 до 231 - 1 включительно. Если решений несколько, выведите любое.

Примеры
входные данныеСкопировать
3 2
1 2 1
2 3 2
выходные данныеСкопировать
consistent
1 2 2 
входные данныеСкопировать
3 3
1 2 1
1 1 2
2 3 2
выходные данныеСкопировать
inconsistent
1F. Горы
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
В парке развлечений «Ай-ой-ай» открылся новейший аттракцион: польские горки. Трек состоит из n рельс, присоединенных одна к концу другой. Начало первой рельсы находится на высоте 0. Оператор Петя может конфигурировать аттракцион, изменяя по своему желанию подъём нескольких последовательных рельс. При этом подъём всех остальных рельс не изменяется. При каждом изменении конфигурации рельс положение следующих за изменяемыми подбирается таким образом, чтобы весь трек оставался связным.

Каждый запуск вагонетки осуществляется с энергией, достаточной для достижения высоты h. Это значит, что вагонетка будет двигаться до тех пор, пока высота не превысит h, либо пока не закончится трек.

По записям о всех изменениях конфигурации рельс и временах запусков вагонетки для каждого запуска определите, сколько рельс вагонетка проедет до остановки.

Трек можно представить как последовательность n подъемов di, по одному на рельс. Изначально рельсы горизонтальны, то есть di = 0 для всех i.


Каждое изменение конфигурации определяется числами a, b и D: все рельсы с a-й по b-ю включительно после этого действия имеют подъем, равный D.


Каждый запуск вагонетки определяется единственным целым числом h — максимальной высотой, на которую способна подняться вагонетка.

Входные данные
В первой строке записано целое число n (1 ≤ n ≤ 109) — число рельс. Следующие строки содержат запросы трех видов:

 a b D — изменение конфигурации. Рельсы с a-й по b-ю включительно после выполнения запроса имеют подъем, равный D.
 h — запуск вагонетки. Требуется найти число рельс, которое проедет вагонетка, которая способна подняться на высоту h.
 — конец ввода. Этот запрос встретится ровно один раз в конце файла.
В любой момент времени высота любой точки трека лежит в промежутке от 0 до 109. Во вводе не более 100 000 строк.

Выходные данные
Для каждого запроса  выведите единственное целое число — количество рельс, которое проедет вагонетка.

Пример
входные данныеСкопировать
4
Q 1
I 1 4 2
Q 3
Q 1
I 2 2 -1
Q 3
E
выходные данныеСкопировать
4
1
0
3
1G. K-я порядковая статистика на отрезке
ограничение по времени на тест5 s.
ограничение по памяти на тест512 MB
вводstandard input
выводstandard output
Дан массив из N неотрицательных чисел, строго меньших 109. Вам необходимо ответить на несколько запросов о величине k-й порядковой статистики на отрезке [l,r].

Входные данные
Первая строка содержит число N (1≤N≤450000) — размер массива.

Вторая строка может быть использована для генерации ai — начальных значений элементов массива. Она содержит три числа a1, l и m (0≤a1,l,m<109); для i от 2 до N
ai=(ai−1⋅l+m)mod109.
В частности, 0≤ai<109.

Третья строка содержит одно целое число B (1≤B≤1000) — количество групп запросов.

Следующие B строк описывают одну группу запросов. Каждая группа запросов описывается 10 числами. Первое число G обозначает количество запросов в группе. Далее следуют числа x1, lx и mx, затем y1, ly и my, затем, k1, lk и mk (1≤x1≤y1≤N, 1≤k1≤y1−x1+1, 0≤lx,mx,ly,my,lk,mk<109). Эти числа используются для генерации вспомогательных последовательностей xg и yg, а также параметров запросов ig, jg и kg (1≤g≤G)
xgygigjgkg=====((ig−1−1)⋅lx+mx)modN)+1,((jg−1−1)⋅ly+my)modN)+1,min(xg,yg),max(xg,yg),(((kg−1−1)⋅lk+mk)mod(jg−ig+1))+1,2≤g≤G2≤g≤G1≤g≤G1≤g≤G2≤g≤G
Сгенерированные последовательности описывают запросы, g-й запрос состоит в поиске kg-го по величине числа среди элементов отрезка [ig,jg].

Суммарное количество запросов не превосходит 600000.

Выходные данные
Выведите единственное число — сумму ответов на запросы.

Пример
входные данныеСкопировать
5
1 1 1
5
1
1 0 0 3 0 0 2 0 0
1
2 0 0 5 0 0 3 0 0
1
1 0 0 5 0 0 5 0 0
1
3 0 0 3 0 0 1 0 0
1
1 0 0 4 0 0 1 0 0
выходные данныеСкопировать
15 
2A. Разреженные таблицы
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Дан массив из n чисел. Требуется написать программу, которая будет отвечать на запросы следующего вида: найти минимум на отрезке между u и v включительно.

Входные данные
В первой строке зданы три натуральных числа n, m (1⩽n⩽105, 1⩽m⩽107) и a1 (0⩽a1<16714589) — количество элементов в массиве, количество запросов и первый элемент массива соответственно. Вторая строка содержит два натуральных числа u1 и v1 (1⩽u1,v1⩽n) — первый запрос.

Для того, чтобы размер ввода был небольшой, массив и запросы генерируются.

Элементы a2,a3,…,an задаются следующей формулой:
ai+1=(23⋅ai+21563)mod16714589.
Например, при n=10, a1=12345 получается следующий массив: a = (12345, 305498, 7048017, 11694653, 1565158, 2591019, 9471233, 570265, 13137658, 1325095).

Запросы генерируются следующим образом:

ui+1=((17⋅ui+751+ri+2i)modn)+1, vi+1=((13⋅vi+593+ri+5i)modn)+1,
где ri — ответ на запрос номер i.
Обратите внимание, что ui может быть больше, чем vi.

Выходные данные
В выходной файл выведите um, vm и rm (последний запрос и ответ на него).

Примеры
входные данныеСкопировать
10 8 12345
3 9
выходные данныеСкопировать
5 3 1565158
Примечание
Можно заметить, что массивы u, v и r можно не сохранять в памяти полностью.

Запросы и ответы на них выглядят следующим образом:

i12345678ui3101105235vi912109123ri57026512345123451325095570265123453054981565158
Эта задача скорее всего не решается стандартными интерпретаторами Python 2 и Python 3. Используйте соответствующие компиляторы PyPy.

Условие недоступно на русском языке
3A. Rectangles
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output
You are given a grid T of size N × M. Each element of this grid is a rectangle Tij, for 0 ≤ i < N and 0 ≤ j < M. Rectangle Tij is described by four integers (xij1, yij1, xij2, yij2), (xij1, yij1) and (xij2, yij2) are the coordinates of the corners of rectangle. Sides of the rectangle are parallel to the axis.

Then you are given queries. Each query consists of four integers: (r1, c1, r2, c2). Answer to this query is the area of a shape, equal to the intersection of all such rectangles Tij, that min (r1, r2) ≤ i ≤ max (r1, r2) and min (c1, c2) ≤ j ≤ max (c1, c2). There are a lot of queries, so we ask you to find the sum of answers to all queries, modulo 109 + 7.

Input
The first line contains two integers N and M  — the dimensions of T. (1 ≤ N, M ≤ 127). The next N lines contain a description of T: in the (i + 1)-th line, the (j + 1)-th tuple of four integers xij1 yij1 xij2 yij2 is describing the rectangle Tij. It is guaranteed that |xijk|, |yijk| ≤ 106.

In the separate line, you are given four integers. The first one of them is an integer Q  — the number of queries (1 ≤ Q ≤ 5·106). The next three integers are A, B, v0 (0 ≤ A, B, v0 < 109 + 7). Using these integers, the sequence {vi} is generated, .

Then, the k-th query (the queries are one-indexed) is described by four integers: .

Output
Print the sum of answers to all queries, modulo 109 + 7.

Examples
inputСкопировать
2 2
0 0 2 2 1 1 3 3
0 3 2 1 1 2 3 0
1 500000003 4 2
outputСкопировать
1
inputСкопировать
3 2
8 -1 -7 6 6 8 9 10
-4 -10 4 9 -3 -8 6 9
-2 -9 3 8 -5 7 7 3
5 303164476 273973578 65779139
outputСкопировать
85
Note
In the first example, the query is of the form (1,0,0,1), so this query is about the whole grid. The intersection of all rectangles in the grid is a square with corners in points (1, 1) and (2, 2). Its area is equal to 1.

In the second example, queries are (0,1,1,1), (1,0,2,0), (0,0,2,1), (0,1,1,1), (0,1,0,0). The answer to the first query is 85, the answers to all other queries are 0.

3B. Окна
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
На экране расположены прямоугольные окна, каким-то образом перекрывающиеся (со сторонами, параллельными осям координат). Вам необходимо найти точку, которая покрыта наибольшим числом из них.

Входные данные
В первой строке входного файла записано число окон n (1≤n≤50000). Следующие n строк содержат координаты окон x(1,i) y(1,i) x(2,i) y(2,i), где (x(1,i),y(1,i)) — координаты левого верхнего угла i-го окна, а (x(2,i),y(2,i)) — правого нижнего (на экране компьютера y растет сверху вниз, а x — слева направо). Все координаты — целые числа, по модулю не превосходящие 2⋅105.

Выходные данные
В первой строке выходного файла выведите максимальное число окон, покрывающих какую-либо из точек в данной конфигурации. Во второй строке выведите два целых числа, разделенные пробелом — координаты точки, покрытой максимальным числом окон. Окна считаются замкнутыми, т.е. покрывающими свои граничные точки.

Примеры
входные данныеСкопировать
2
0 0 3 3
1 1 4 4
выходные данныеСкопировать
2
1 3
входные данныеСкопировать
1
0 0 1 1
выходные данныеСкопировать
1
0 1
K-й максимум
ограничение по времени на тест2 секунды
ограничение по памяти на тест512 мегабайт
вводстандартный ввод
выводстандартный вывод
Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить k-й максимум.

Входные данные
Первая строка входного файла содержит натуральное число n — количество команд (n≤100000). Последующие n строк содержат по одной команде каждая. Команда записывается в виде двух чисел ci и ki — тип и аргумент команды соответственно (|ki|≤109). Поддерживаемые команды:

 1: Добавить элемент с ключом ki.
 0: Найти и вывести ki-й максимум.
-1: Удалить элемент с ключом ki.
Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными ключами или удалять несуществующие элементы. Также гарантируется, что при запросе ki-го максимума, он существует.

Выходные данные
Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержащая единственное число — ki-й максимум.

Пример
входные данныеСкопировать
11
1 5
1 3
1 7
0 1
0 2
0 3
-1 5
1 10
0 1
0 2
0 3
выходные данныеСкопировать
7
5
3
10
7
3
4B. Переместить в начало
ограничение по времени на тест6 секунд
ограничение по памяти на тест512 мегабайт
вводстандартный ввод
выводстандартный вывод
Вам дан массив a1 = 1, a2 = 2, ..., an = n и последовальность операций: переместить элементы с li по ri в начало массива. Например, для массива 2, 3, 6, 1, 5, 4, после операции (2, 4) новый порядок будет 3, 6, 1, 2, 5, 4. А после применения операции (3, 4) порядок элементов в массиве будет 1, 2, 3, 6, 5, 4.

Выведите порядок элементов в массиве после выполнения всех операций.

Входные данные
В первой строке входного файла указаны числа n и m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 100 000) — число элементов в массиве и число операций. Следующие m строк содержат операции в виде двух целых чисел: li и ri (1 ≤ li ≤ ri ≤ n).

Выходные данные
Выведите n целых чисел — порядок элементов в массиве после применения всех операций.

Пример
входные данныеСкопировать
6 3
2 4
3 5
2 2
выходные данныеСкопировать
1 4 5 2 3 6 
4C. Своппер
ограничение по времени на тест4 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Современные компьютеры зацикливаются в десятки раз эффективнее человека
Рекламный проспект OS Vista-N
Перед возвращением в штаб-квартиру корпорации Аазу и Скиву пришлось заполнить на местной таможне декларацию о доходах за время визита. Получилась довольно внушительная последовательность чисел. Обработка этой последовательности заняла весьма долгое время.

— Своппер кривой, — со знанием дела сказал таможенник.

— А что такое своппер? — спросил любопытный Скив.

Ааз объяснил, что своппер — это структура данных, которая умеет делать следующее.

Взять отрезок чётной длины от x до y и поменять местами число x с x + 1, x + 2 с x + 3, и т.д.
Посчитать сумму чисел на произвольном отрезке от a до b.
Учитывая, что обсчёт может затянуться надолго, корпорация «МИФ» попросила Вас решить проблему со своппером и промоделировать ЭТО эффективно.

Входные данные
Во входном файле заданы один или несколько тестов. В первой строке каждого теста записаны число N — длина последовательности и число M — число операций (1 ≤ N,  M ≤ 100 000). Во второй строке теста содержится N целых чисел, не превосходящих 106 по модулю — сама последовательность. Далее следуют M строк — запросы в формате 1 xi yi — запрос первого типа, и 2 ai bi — запрос второго типа. Сумма всех N и M по всему файлу не превосходит 200 000. Файл завершается строкой из двух нулей. Гарантируется, что xi < yi, а ai ≤ bi.

Выходные данные
Для каждого теста выведите ответы на запросы второго типа, как показано в примере. Разделяйте ответы на тесты пустой строкой.

Пример
входные данныеСкопировать
5 5
1 2 3 4 5
1 2 5
2 2 4
1 1 4
2 1 3
2 4 4
3 1
1 2 3
2 1 2
0 0
выходные данныеСкопировать
Swapper 1:
10
9
2
 
Swapper 2:
3
4D. Развороты
ограничение по времени на тест1 секунда
ограничение по памяти на тест512 мегабайт
вводстандартный ввод
выводстандартный вывод
Вам дан массив a1 = 1, a2 = 2, ..., an = n и последовательность операций: переставить элементы с li по ri в обратном порядке. Например, для массива 1, 2, 3, 4, 5, после операции (2, 4) новый порядок будет 1, 4, 3, 2, 5. А после применения операции (3, 5) порядок элементов в массиве будет 1, 4, 5, 2, 3.

Выведите порядок элементов в массиве после выполнения всех операций.

Входные данные
В первой строке входного файла указаны числа n и m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 100 000) — число элементов в массиве и число операций. Следующие m строк содержат операции в виде двух целых чисел: li и ri (1 ≤ li ≤ ri ≤ n).

Выходные данные
Выведите n целых чисел — порядок элементов в массиве после применения всех операций.

Пример
входные данныеСкопировать
5 3
2 4
3 5
2 2
выходные данныеСкопировать
1 4 5 2 3 
5A. LCA
ограничение по времени на тест5 секунд
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Дано подвешенное дерево с корнем в первой вершине. Вам нужно ответить на m запросов вида "найти LCA двух вершин". LCA вершин u и v в подвешенном дереве — это наиболее удалённая от корня дерева вершина, лежащая на обоих путях от u и v до корня.

Входные данные
В первой строке задано целое число n — число вершин в дереве (1≤n≤2⋅105).

В следующих n−1 строках записано одно целое число x. Число x на строке i означает, что x — предок вершины i(x<i).

Затем дано число m.

Далее заданы m (0≤m≤5⋅105) запросов вида (u,v) — найти LCA двух вершин u и v (1≤u,v≤n; u≠v).

Выходные данные
Для каждого запроса выведите LCA двух вершин на отдельной строке.

Примеры
входные данныеСкопировать
5
1
1
2
3
2
2 3
4 5
выходные данныеСкопировать
1
1
входные данныеСкопировать
5
1
1
2
2
3
4 5
4 2
3 5
выходные данныеСкопировать
2
2
1
5B. Самое дешевое ребро
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Дано подвешенное дерево с корнем в первой вершине. Все ребра имеют веса (стоимости). Вам нужно ответить на m запросов вида «найти для двух вершин минимум среди стоимостей ребер на пути между ними».

Входные данные
В первой строке файла записано одно число — n. (количество вершин).

В следующих n−1 строках записаны два числа — x и y. Число x на строке i означает, что x — предок вершины i+1, y означает стоимость ребра.

x≤i,|y|≤106.

В следующей строке файла записано число m — количество запросов.

Далее m запросов вида (x,y) — найти минимум на пути из x в y (x≠y).

Ограничения: 2≤n≤5⋅104,0≤m≤5⋅104.

Выходные данные
m строк — ответы на запросы.

Пример
входные данныеСкопировать
5
1 2
1 3
2 5
3 2
2
2 3
4 5
выходные данныеСкопировать
2
2
5C. Чип и Дейл в лабиринте
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Чип и Дейл спешат на помощь! Но внимательные зрители знают, что помощь как правило нужна самим Чипу и Дейлу, поэтому сегодня вам надо будет сыграть роль сообразительной Гаечки. Итак, Чип и Дейл снова попали в лапы к Толстопузу. Кот очень не любит грызунов и поэтому приготовил им изощренное испытание. Он собирается поместить их в лабиринт и посмотреть смогут ли они из него выбраться. Лабиринт представляет собой дерево, в котором каждое ребро имеет одно направление. Гаечка подслушала разговор Толстопуза со своими сообщниками и теперь знает несколько возможных вариантов: в какую точку лабиринта поместят её друзей, и где будет выход. Для каждого такого варианта она хочет понять, смогут ли Чип и Дейл найти выход, или нет.

Входные данные
В первой строке записано число n (n ≤ 105) — количество вершин дерева. В следующих n - 1 строках описаны ребра дерева. В (i + 1)-й строке записано номера вершин ai, bi, означающие, что в дереве есть ребро из вершины ai в вершину bi.

Далее на отдельной строке записано число m (m ≤ 105) — количество запросов. После этого идут m строк с описанием запросов, в (n + 1 + i)-й строке записаны через пробел числа xi и yi.

Выходные данные
Для каждого запроса на отдельной строке требуется вывести «Yes», если в графе есть путь между вершинами xi и yi, и «No» иначе.

Пример
входные данныеСкопировать
4
1 2
3 1
4 1
6
1 2
3 2
2 3
4 2
4 3
2 1
выходные данныеСкопировать
Yes
Yes
No
Yes
No
No
5D. Usmjeri
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Нам дано дерево с N узлами, обозначенными различными положительными целыми числами от 1 до N. Кроме того, вам дано M пар узлов из дерева в форме (a1, b1), (a2, b2),…, (aM, bM). Нам нужно направить каждое ребро дерева таким образом, чтобы для каждой данной пары узлов (ai, bi) был путь от ai до bi или от bi до ai. Сколько существует способов достичь этого? Поскольку решение может быть довольно большим, определите его по модулю 109+7.

Входные данные
В первой строке входных данных содержатся натуральные числа N и M (1≤N,M≤3∗105), количество узлов в дереве и количество заданных пар узлов соответственно. Каждый из следующих N — 1 Строки содержат два положительных целых числа, метки узлов, связанных с ребром. i-я из следующих M строк содержит два разных положительных целых числа ai и bi, метки узлов из i-й пары узлов. Все пары узлов будут взаимно разными.

Выходные данные
Вы должны вывести одну строку, содержащую общее количество различных способов направления ребер дерева, которые отвечают требованию задачи, по модулю 109+7.

Примеры
входные данныеСкопировать
4 1
1 2
2 3
3 4
2 4
выходные данныеСкопировать
4
входные данныеСкопировать
7 2
1 2
1 3
4 2
2 5
6 5
5 7
1 7
2 6
выходные данныеСкопировать
8
входные данныеСкопировать
4 3
1 2
1 3
1 4
2 3
2 4
3 4
выходные данныеСкопировать
0
Примечание
Дерево — это граф, который состоит из N узлов и N - 1 ребер, так что существует путь от каждого узла к каждому другому узлу.

5E. Сажаем траву
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
У Фермера Джона есть n пастбищ (2 ≤ n ≤ 100 000), соединенных n - 1 двунаправленными дорогами так, что между любыми двумя пастбищами существует ровно один путь.

Бесси, любимая корова фермера Джона, пожаловалась, что вдоль дорог не растет трава, и фермер решил это исправить, посадив несколько кустов травы вдоль дорог.

Он делает это, используя процедуру, которая состоит из m шагов.

На каждом шаге происходит одна из двух вещей:

P-запрос: фермер Джон выбирает два пастбища и высаживает по одному кусту травы на каждой дороге на пути между ними.
Q-запрос: Бесси выбирает дорогу и спрашивает, сколько кустов травы на ней высажено.
Помогите фермеру отвечать на вопросы Бесси.

Входные данные
Первая строка содержит два натуральных числа n и m (2 ≤ n ≤ 105, 1 ≤ m ≤ 105).

Следующие n - 1 строк описывают дороги, каждая дорога описывается номерами пастбищ, которые она соединяет.

Следующие m строк описывают шаги фермера. Первый символ каждой строки либо P, либо Q - тип запроса. Затем следуют два разделенных пробелом целых числа ai и bi (1 ≤ ai, bi ≤ n), которые описывают путь для P-запроса или дорогу для Q-запроса.

Выходные данные
Выведите ответы на запросы в том порядке, в котором поступали эти запросы, по одному ответу в строке.

Примеры
входные данныеСкопировать
4 6
1 4
2 4
3 4
P 2 3
P 1 3
Q 3 4
P 1 4
Q 2 4
Q 1 4
выходные данныеСкопировать
2
1
2
5F. Пещеры и туннели
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводcaves.in
выводcaves.out
После посадки на Марс учёные нашли странную систему пещер, соединённых туннелями. И учёные начали исследовать эту систему, используя управляемых роботов. Было обнаружено, что существует ровно один путь между каждой парой пещер. Но потом учёные обнаружили специфическую проблему. Иногда в пещерах происходят небольшие взрывы. Они вызывают выброс радиоактивных изотопов и увеличивают уровень радиации в пещере. К сожалению, роботы плохо выдерживают радиацию. Но для исследования они должны переместиться из одной пещеры в другую. Учёные поместили в каждую пещеру сенсор для мониторинга уровня радиации. Теперь они каждый раз при движении робота хотят знать максимальный уровень радиации, с которым придётся столкнуться роботу во время его перемещения. Как вы уже догадались, программу, которая это делает, будете писать вы.

Входные данные
Первая строка входного файла содержит одно целое число N (1 ≤ N ≤ 100 000) — количество пещер. Следующие N - 1 строк описывают туннели. Каждая из этих строк содержит два целых числа — ai и bi (1 ≤ ai, bi ≤ N), описывыющие туннель из пещеры с номером ai в пещеру с номером bi. Следующая строка содержит целое число Q (1 ≤ Q ≤ 100 000), означающее количество запросов. Далее идут Q запросов, по одному на строку. Каждый запрос имеет вид «C U V», где C — символ «I» либо «G», означающие тип запроса (кавычки только для ясности). В случае запроса «I» уровень радиации в U-й пещере (1 ≤ U ≤ N) увеличивается на V (0 ≤ V ≤ 10 000). В случае запроса «G» ваша программа должна вывести максимальный уровень радиации на пути между пещерами с номерами U и V (1 ≤ U, V ≤ N) после всех увеличений радиации (запросов «I»), указанных ранее. Предполагается, что изначальный уровень радиации равен 0 во всех пещерах, и он никогда не уменьшается со временем (потому что период полураспада изотопов много больше времени наблюдения).

Выходные данные
Для каждого запроса «G» выведите одну строку, содержащую максимальный уровень радиации.

Примеры
входные данныеСкопировать
4
1 2
2 3
2 4
6
I 1 1
G 1 1
G 3 4
I 2 3
G 1 1
G 3 4
выходные данныеСкопировать
1
0
1
3
5G. Дерево
ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Гений Евгеньевич давно мечтал о дереве. Сейчас в моде деревья с n вершинами, на каждой из которых написано число xi. Долгожданный день настал, и Гений Евгеньевич смог себе приобрести такое дерево. Вернувшись из магазина после покупки, он начал считать различные величины на этом дереве. Все ему давалось очень просто, пока он не решил найти путь в этом дереве, значение величины l(p(u, v))·min(xu, xv) для которого максимально. Здесь p(u, v) — путь между вершинами u и v, l(p) — длина пути p в ребрах.

Уже который день Гений Евгеньевич не выходит на улицу. Его друзья, естественно, начали волноваться. Они просят Вас помочь Гению Евгеньевичу справиться с задачей.

Входные данные
В первой строке входных данных задано целое число n (1 ≤ n ≤ 105) — количество вершин в дереве.

Во второй строке заданы n чисел xi (1 ≤ xi ≤ 109) — числа написанные на вершинах. На i-й вершине написано число xi.

В следующих n - 1 строках заданы пары целых чисел ai, bi (1 ≤ ai, bi ≤ n) — рёбра в дереве.

Выходные данные
Выведите максимальное значение величины, описанной в условии.

Примеры
входные данныеСкопировать
8
9 2 8 8 7 2 1 2
2 1
3 1
4 1
5 2
6 4
7 5
8 5
выходные данныеСкопировать
21
5H. Найти ближайшую
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Дано дерево из n вершин, цвет i-й вершины равен ai. Необходимо обработать q запросов (vi,ci): найти расстояние от vi до ближайшей вершины цвета ci. Расстояние между вершинами — минимальное количество рёбер в пути между ними.

Входные данные
Первая строка содержит n (1≤n≤105).

Следующая строка содержит n−1 число p1,…pn−1 (0≤pi<i). pi — отец вершины i.

Следующая строка содержит числа a1,…,an (0≤ai<n).

Следующая строка содержит число q (1≤q≤105).

Следующие q строк содержат числа vi, ci (0≤vi<n, 0≤ci<n).

Выходные данные
Для каждого запроса выведите расстояние до ближайшей вершины требуемого цвета, или −1, если такой нет.

Пример
входные данныеСкопировать
5
0 1 1 3
1 2 3 2 1
9
0 1
0 2
0 3
1 0
2 1
2 2
3 3
3 1
4 2
выходные данныеСкопировать
0 1 2 -1 2 1 2 1 1 
