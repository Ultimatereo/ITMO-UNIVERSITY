(defn abstractV [f] (fn [& vs] (apply (partial mapv f) vs)))
(def v+ (abstractV +))
(def v- (abstractV -))
(def v* (abstractV *))
(def vd (abstractV /))

(defn scalar [v1, v2] (reduce + (v* v1 v2)))
(defn vect [v1, v2] (vector (- (* (nth v1 1) (nth v2 2)) (* (nth v2 1) (nth v1 2)))
                            (- (* (nth v1 2) (nth v2 0)) (* (nth v2 2) (nth v1 0)))
                            (- (* (nth v1 0) (nth v2 1)) (* (nth v2 0) (nth v1 1)))
                            )
  )
(defn v*s [v & s] (let [c (apply * s)] (mapv (partial * c) v)))
(defn transpose [m] (apply mapv vector m))

(defn abstractM [f] (fn [& ms] (apply (partial mapv (abstractV f)) ms)))
(def m+ (abstractM +))
(def m- (abstractM -))
(def m* (abstractM *))
(def md (abstractM /))

(defn m*s [m & s] (let [c (apply * s)]
                    (mapv (fn [v] (v*s v c))
                          m))
  )
(defn m*v [m v] (mapv (fn [v1] (scalar v1 v)) m))
(defn m*m [m1 m2] (transpose (mapv (fn [v2] (m*v m1 v2)) (transpose m2))))
(defn abstractS [f] (fn abstractS-iter [& ss] (if (vector? (first ss))
                                                (apply (partial mapv abstractS-iter) ss)
                                                (apply f ss))))
(def s+ (abstractS +))
(def s- (abstractS -))
(def s* (abstractS *))
(def sd (abstractS /))